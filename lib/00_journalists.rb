twitter_handle = ["@jcunniet","@PaulLampon","@Aziliz31","@ssoumier","@marionsouzeau","@gaellombart","@bendarag","@AurelieLebelle","@julienduffe","@thomaspoupeau","@LilyRossignol","@ClairGuedon","@stephanieauguy","@claw_prolongeau","@_JulieMenard","@LColcomb","@Zlauwereys","@MeLonguet","@DorotheeLN","@NolwennCosson","@ADaboval","@Remibaldy","@bderveaux","@amandechap","@ELODIESOULIE","@nbongarcon","@HeloAb","@Panamorama","@gregplou","@BenoitBerthe","@LauraBruneau89","@Anthony_Lieures","@Sharonwaj","@mcsonkin","@pverduzier","@emiliel3","@Julien_MARION","@SophiFay","@bdelombre","@annalecerf","@AdriaBudry","@DejNikolic","@iJaffre","@CyrusleVirus","@GPardigon","@e_vallerey","@IsabelleSouquet","@AudeDavidRossi","@Yoann_Pa","@CeliaPenavaire","@perraultvincent","@cboulate","@JustineWeyl","@Paulinejacot","@juliechab","@aslechevallier","@phnou","@Seb_Pommier","@Alex_Bensaid","@GuillaumeGaven","@annelaurechouin","@Oliviader","@guerricp","@JMMarchaut","@cyceron","@gregory_raymond","@vhunsinger","@l_peillon","@fannyguinochet","@EAssayag","@KibweAdom","@YvonHerry","@JohanGarciajg","@saidlabidi","@lauranneprov","@LeaDavy","@francois_remy","@CGuicheteau","@FloMaillet","@m_perroud","@oBrunet_TSMF","@MoonVdc","@jc2taille","@NellyMoussu","@VirginK","@b_misa","@FabriceCouste","@barbara_prose","@lelia2m","@brunoaskenazi","@laurenechamp","@ysisbox","@juliengagliardi","@PierreLel","@kdeniau","@_TerraInc","@DominicArpin","@antoinfonteneau","@nanotousch","@jb_roch","@YaniKhezzar","@Anne_Bechet","@NCapart","@SamyBenNaceur","@Joumany","@Julietteraynal","@TGiraudet","@SaraTanit","@HappeFrederic","@antoinellorca","@michelpicot","@Sev_Ryne","@bobdobolino","@murdever","@YGrandmontagne","@Mnyo","@EdKOSCIANSKI","@tnoisette","@jankari","@delbello_rom","@rflechaux","@NadiaSorelli","@IT_Digital","@abarbaux","@PhilippeLeroy","@schaptal","@marionspee","@lisavignoli","@ChloeAeberhardt","@MartineJacot","@JuliaPascualita","@curieusedetout","@sgraveleau","@bif_o","@ElisaPineau","@zinebdryef","@apiquard","@pierrehaski","@StephanieDelmas","@Blandine_Garot","@vergara_i","@evan_lebastard","@SophieVclt","@OlivierLevrault","@alicedorgeval","@LouiseMalnoy","@alix_fx","@pierre_baudis","@LucMagoutier","@AgatheMuller","@SGianninelli","@PaulineBoyer33","@NaomiHalll","@romaindlx","@marionbr","@Burtschy","@JacobEtienne","@as_lizzani","@marie_simon","@LaureDaussy","@FabriceAmedeo","@min","@LoubnaChlaikhy","@PlummerWilliam","@OlivierMarin1","@alaurefremont","@mwesfreid","@ChBaDe","@pmathon","@theobaldmarie","@Lnpagesy","@marclandre","@paoliniesther","@Feertchak","@JBLitzler","@GuillaumeErrard","@quentinperinel","@TristanQM","@mlbo","@constancejamet","@LoraTerrazas","@emiliegeffray","@Mathilde_Sd","@CaroPiquet","@DCanivez","@TIM_7375","@blandinelc","@ivanrioufol","@arthurberdah","@SarahLecoeuvre","@guillaume_gui","@DamienMercereau","@W_Chloe","@Assma_MD","@EugenieBastie","@HiTech_lexpress","@bcondominas","@Laurie_Z_","@jeanfrancgerard","@MathieuPagura","@BGUYF","@AlainPiffaretti","@AudreyKucinskas","@julienhory","@Pierrefalga","@TiphThuillier","@cdaniez","@LigerBaptiste","@D_Peras","@julie_dlb","@Fatiha_Temmouri","@julian2lamancha","@GaetaneDeljurie","@JulianMattei","@M_Vicuna","@DeBruynOlivier","@Nehed_Jendoubi","@antoine_grenapi","@ColonnaGen","@VictoriaGairin","@Clement_Lacombe","@TVigoureux","@MargauxObriot","@solinedelos","@RocheSabine","@dangerkens","@EdouardDutour","@MDondeyne","@DupuisNathalie1","@bouscarel","@Mathieu2jean","@Sophie_T_J","@laurentcalixte","@patrockwilliams","@PascaleKremer","@AlexJaquin","@LauraIsaaz","@cath_robin","@Del_Gautherin","@Isaduriez","@lucietuile","@AugeyBastien","@mcastagnet","@AminaKalache","@mvaudano","@CParrot","@ombelinetips","@_JoinLion","@BarbolosiRose","@ToiBruno1","@FloraClodic","@xjbdx","@ceci_est_un_handle_vraiment_long","@AlexiaEy","@Emjy_STARK","@elcoco01","@rabilebon","@pflovens_","@FabriceFrossard","@MorganeSERRES","@MarjolaineKoch","@edgarsnow","@SRNLF","@CChassigneux","@KerinecMoran","@NassiraELM","@NewsRicard","@Sandreene","@Emilezrt","@Pierre_Do","@Micode","@CColumelli","@DavidAbiker","@ClementBergantz","@benjaminrabier","@celinekallmann","@edwyplenel","@C_Barbier","@JJBourdin_RMC","@LaurenceFerrari","@aslapix","@IsaMillet","@MaximeSwitek","@tomjoubert","@jszanchi","@roqueeva","@XavierBiseul","@florencesantrot","@AntoineCrochet","@freeman59","@MaudeML","@philippe_gulpi","@mathieum76","@kiouari","@imanemoustakir","@BenedicteMallet","@Emilie_Brouze","@antoinebarret","@_nicolasbocquet","@remibuhagiar","@CourretB","@AymericRobert","@miraelmartins","@pmaniere","@jesuisraphk","@David_Ingram","@pcelerier","@technomedia","@Geraldinedauver","@ThierryLabro","@Newsdusud","@nrauline","@gbregeras","@SCouasnonBFM","@actualites_nrv","@dimitrimoulins","@oli_aura","@FabieChiche","@Vincent_Raimblt","@ChristophGreuet","@PAlbuchay","@MarrauddesGrot","@vtalmon","@cedric","@olivierfrigara","@Julien_Jay","@LydiaBerroyer","@Shuua","@datisdaz","@Steuph","@ameliecharnay","@Bruno_LesNums","@LelloucheNico","@CciliaDiQuinzio","@Elodie_C","@SylvRolland","@Kocobe","@FL_Debes","@jdupontcalbo","@GarciaVictor_","@NicoRichaud","@RHoueix","@simottel","@DamienLicata","@annabelle_L","@Lea_Lejeune","@axel_deb","@marin_eben","@ptiberry","@MatthieuDelach","@sandrinecassini","@benjaminferran","@ppgarcia75","@NotPatrick","@ivalerio","@FabienneSchmitt","@alexgoude","@JeromeColombain","@manhack","@Capucine_Cousin","@Fsorel","@oliviertesquet","@marjoriepaillon","@ginades","@PierreTran","@DelphineCuny","@reesmarc","@lauratenoudji","@ldupin","@carolinedescham","@Lucile_Quillet","@cgabizon","@Allocab","@epenser","@JAGventeprivee","@frwrds","@Laure__Bourdon","@Xavier75","@maximeverner","@s_jourdain","@LoriHelloc"]

# méthode pour enlever les '@' au début des handle
def handle_without_at(array_name)
  sub_array = []

  array_name.each do |element|
    sub_array << element.gsub('@', '')
  end

  return sub_array
end

# Combien y a-t-il de handle dans cette array ?
def count_handle(array_name)
  sub_array = handle_without_at(array_name)
  number_of_handle = 0

  sub_array.each do
    number_of_handle += 1
  end

  puts "Il y a #{number_of_handle} handle de Twitter dans ce array
  "
  return number_of_handle
end

# Quel est le handle le plus court de cette liste ?
def shortest_handle(array_name)
  sub_array = handle_without_at(array_name)
  shortest_element_length = sub_array[0].length
  array_index = 0

  sub_array.each_with_index do |array_element, i|
    current_length = array_element.length
    if current_length < shortest_element_length
      shortest_element_length = current_length
      array_index = i
    else
    end
  end

  puts "Le handle le court est celui de #{array_name[array_index]} avec #{shortest_element_length} caractères ! (le '@' ne compte pas ;) )
  "

  # Ou encore beaucoup plus simple pour trouver le minimum :
  # array_name.min_by(&:length)
end

# Combien y-a-t'il de handle contenant 5 caractères (le @ ne compte pas pour un caractère)
def count_handle_five(array_name)
  sub_array = handle_without_at(array_name)
  count = 0
  sub_array.each do |element_name|
    if element_name.length == 5
      count += 1
    else
    end
  end
  puts "Il y a #{count} handle qui contient exactement 5 caractères ! Le '@' ne compte pas :)
  "
  return count
end

# Combien commencent par une majuscule (première lettre juste après le @) ?

# Façon de faire numéro 1 (ne fonctionne pas pour les handle avec les '_')
# def count_capital(array_name)
#   sub_array = handle_without_at(array_name)
#   count = 0
#   sub_array.each do |element|
#     if element[0] == element[0].upcase && element[0] != element[0].downcase
#       count += 1
#     elsif element[0] == element[0].downcase && element[0] != element[0].upcase
#       if element[1] == element[1].upcase && element[1] != element[1].downcase
#         count +=1
#       end
#     end
#   end
#   puts count
#   return count
# end

def count_capital(array_name)
  sub_array = handle_without_at(array_name)

  nb_cap = sub_array.count {|element| element[0] =~ /[A-Z]/}
  puts "Il y a #{nb_cap} handle qui commence avec une lettre capitale ! Sans compter les handle avec '_' 
  "

  sub_array_underscore = []
  sub_array.each do |element|
    if element[0] == "_"
      sub_array_underscore << element
    else
    end
  end

  nb_cap_underscore = sub_array_underscore.count {|element| element[1] =~ /[A-Z]/}
  puts "Il y a #{nb_cap_underscore} handle qui commence avec une lettre capitale après un '_' ! =D
  "

end

# Trie la liste de handle par ordre alphabétique.
def sort_alphabetically(array_name)
  sub_array = handle_without_at(array_name)
  puts "Quand on range par ordre alphabétique, ça donne ça :
  "
  puts array_name.sort(&:casecmp)
end

# Trie la liste de handle par taille des handle (les plus petits en premiers, les plus grands après)
def sort_by_length(array_name)
  puts array_name.sort_by(&:length)
end

# Quelle est la position dans l'array de la personne @epenser ?

# Pour e-penser seulement :
def epenser_position(array_name)
  name = @epenser
  
  position = 0
  array_name.each_with_index do |element, i|
    if element == name
      position = i
    end
  end
  puts "La position du nom est la suivante : #{position}
  "
end

# Pour un nom générique :
def name_position(array_name)
  puts "Qui veut trouver ? Tape son nom EXACTEMENT (à tout hasard, @epenser) :"
  print "> "
  name = gets.chomp
  
  position = 0
  array_name.each_with_index do |element, i|
    if element == name
      position = i
    end
  end
  puts "La position du nom est la suivante : #{position}
  "
end


# Sors-moi une répartition des handle par taille de ces derniers (nombre de handle avec 1 caractère, nombre de handle avec 2 caractères, nombre de handle avec 3 caractères, etc)

# Test n°1
def repartition(array_name)
  sub_array = handle_without_at(array_name)
  length_array = []

  sub_array.each do |element|
    length_array << element.length
  end

  tallied_length = length_array.sort.tally

  tallied_length.each do |key, value|
    puts "Il y a #{value} handle contenant #{key} caractères
    "
  end

end

# Test 2 => non fonctionnel en l'état
# def repartition(array_name)
#   sub_array = handle_without_at(array_name)
#   length_array = []
#   sub_array.each do |element|
#     length_array << element.length
#   end
#   length_array = length_array.sort.reverse
  
#   l = length_array[0]
#   i = length_array.count
#   while i > 0

#     i-=1
#   end


# end

def choose_a_method(array_name)
  puts "Sélectionne la méthode que tu souhaites utiliser : \n
  1. count_handle(array_name), qui compte le nombre de handle contenu dans le array de Twitter\n
  2. shortest_handle(array_name), qui sort le handle possédant le moins de caractères\n
  3. count_handle_five(array_name), qui compte le nombre de handle ayant exactement 5 caractères (sans le @)\n
  4. count_capitale(array_name), qui compte le nombre de handle qui commencent par une lettre capitale (bonus, on compte aussi les handle qui commencent par un '_' puis une lettre capitale\n
  5. sort_alphabetically(array_name), qui met les handle de l'array dans l'ordre alphabétique\n
  6. sort_by_length(array_name), qui met les handle de l'array dans l'ordre de la longueur des handle\n
  7. epenser_position(array_name), qui va chercher la position du handle de @epenser dans l'array\n
  71. name_position(array_name), qui donne la position d'un handle donné\n
  8. repartition(array_name), qui donne la répartition des handle selon le nombre de caractères\n"

  puts
  print "> "
  method_selection = gets.chomp.to_i
  case method_selection
  when 1
    count_handle(array_name)
    return false
  when 2
    shortest_handle(array_name)
    return false
  when 3
    count_handle_five(array_name)
    return false
  when 4
    count_capital(array_name)
    return false
  when 5
    sort_alphabetically(array_name)
    return false
  when 6
    sort_by_length(array_name)
    return false
  when 7
    epenser_position(array_name)
    return false
  when 71
    name_position(array_name)
    return false
  when 8
    repartition(array_name)
    return false
  else
    return true
  end
end

def perform(array_name)
  loop = true
  while loop
    loop = choose_a_method(array_name)
    if loop == true
      puts "Ceci ne fait pas parti des possibilités... Laisse-moi répéter :\n"
    end
  end
end


perform(twitter_handle)